'use strict';

let http = require('http');
let https = require('https');
let fs = require('fs');
let console = window.console;

// Utility methods

let html2document = function(html) {
	let tmpl = document.createElement('template');
	tmpl.innerHTML = html;
	return tmpl.content;
}

let html2text = function(html) {
	return html2document(html).textContent;
}

let parseTime = function(time) {
	time = '1970-1-1 '+time.replace('AM',' AM').replace('PM',' PM');
	var dobj = new Date(time);
	if (dobj.getTime()) {
		return {
			h: dobj.getHours(),
			m: dobj.getMinutes(),
			s: dobj.getSeconds()
		};
	} else {
		console.warn(`Cannot parse time: ${time}`);
	}
}

let parseDate = function(date) {
	var dobj = new Date(date);
	if (dobj.getTime()) {
		return {
			y: dobj.getFullYear(),
			m: dobj.getMonth(),
			d: dobj.getDate()
		};
	} else {
		console.warn(`Cannot parse time: ${time}`);
	}
}

// Extraction methods: go through the HTML soup and extract data as-is

/**
 *	Extract the section information
 *
 *	Section information is encoded as Javascript object in a <script> tag
 */
let getSectionDataObj = function(doc) {
	let scripts = doc.querySelectorAll('script');
	for (let i = 0; i < scripts.length; ++i) {
		let lines = scripts[i].text.split('\n');
		for (let j = 0; j < lines.length; j++) {
			var matches = /sectionDataObj(\s)*=(\s)*(.*)/.exec(lines[j]);
			if (matches && matches[3]) {
				return eval(matches[3]);
			}
		}
	}
	throw 'Cannot find data object';
}

/**
 *	Get detailed descriptions from the course info section
 */
let getCourseInfoDetails = function(div) {
	let blocks = div.children;
	let info = {};
	var matches = /^Credit:(.*)/.exec(blocks[0].innerText);
	if (!matches)
		throw 'Cannot find credit info';
	info.credit = matches[1].trim();
	info.description = blocks[1].innerHTML.trim();
	info.requirements = [];
	for (let i = 2; i < blocks.length; i++) {
		info.requirements.push(blocks[i].innerHTML.trim());
	}
	return info;
}

/**
 *	Get course info section (text block) from the html
 */
let getCourseInfo = function(doc) {
	var info = {};
	let infoblock = doc.querySelector('#app-course-info');
	if (!infoblock || !infoblock.children || !infoblock.children.length)
		throw 'Cannot find app-course-info block';
	let blocks = infoblock.children;
	info.code = doc.querySelector('h1').innerText;
	info.title = blocks[0].querySelector('span').innerText.trim();
	for (var i = 1; i < blocks.length; ++i) {
		if (blocks[i].innerText.trim().substr(0,7) == 'Credit:') {
			Object.assign(info, getCourseInfoDetails(blocks[i]));
			++i;
			break;
		}
	}
	info.additional = [];
	// The remaining blocks are added as additional info
	for (; i < blocks.length; ++i) {
		info.additional.push(blocks[i].innerHTML.trim());
	}
	return info;
}


// Parsing methods: take the extracted data and convert into API-friendly objects


/**
 *	Read from the course info text blob
 */
let parseInfo = function(info) {
	let courseobj = {};

	// Parse code
	courseobj.code = info.code;
	var matches = /^([A-Z]{2,}) (\d{3,})/.exec(info.code);
	if (!matches)
		throw 'Cannot parse course code';
	courseobj.dept = matches[1];
	courseobj.number = matches[2];

	// Parse requirements
	courseobj.requirements = {
		raw: info.requirements,
		depend: [],
		exclude: [],
		gened: [],
		other: []
	};

	info.requirements.forEach((line) => {
		// TODO
	});

	// Credit
	matches = false;
	let credit = info.credit.toLowerCase();
	if (matches = /^(\d+) hour/.exec(credit)) {
		courseobj.credit = [parseInt(matches[1])];
	} else if (matches = /^(\d+) to (\d+) hour/.exec(credit)) {
		courseobj.credit = {
			range: [parseInt(matches[1]), parseInt(matches[2])]
		};
	} else if (matches = /^(\d+) or (\d+) hour/.exec(credit)) {
		courseobj.credit = [parseInt(matches[1]), parseInt(matches[2])];
	} else {
		console.warn(`Unparsable credit: ${credit}`);
		courseobj.credit = [credit];
	}

	// Copy
	courseobj.title = info.title;
	courseobj.description = info.description;
	courseobj.additional = info.additional;

	return courseobj;
}

/**
 *	Read from the section info object
 */
let parseSectionObj = function(sections, course) {
	let secsobj = {};
	sections.forEach((section) => {
		var secobj = {};

		// Status
		let status = html2document(section.status);
		secobj.status = {
			code: parseInt(status.querySelector('span.hide').innerText),
			msg: section.availability
		};

		// Credit
		secobj.credit = course.credit;
		if (section.credit) {
			var matches = /^(\d+) hour/.exec(section.credit);
			if (matches) {
				secobj.credit = [parseInt(matches[1])];
			} else {
				console.warn(`Cannot parse section credit: ${section.credit}`);
			}
		}

		// Meetings
		secobj.meetings = [];
		let meet_day = html2document(section.day).querySelectorAll('div');
		let meet_instructor = html2document(section.instructor).querySelectorAll('div');
		let meet_location = html2document(section.location).querySelectorAll('div');
		let meet_section = html2document(section.section).querySelectorAll('div');
		let meet_time = html2document(section.time).querySelectorAll('div');
		let meet_type = html2document(section.type).querySelectorAll('div');
		secobj.section = meet_section[0].innerText.trim();
		secobj.type = meet_type[0].innerText.trim();
		for (let i=0; i<meet_section.length; ++i) {
			let day = meet_day[i].innerText.trim().split(''); // TODO: parse day of week

			let time = /(.*) - (.*)/.exec(meet_time[i].innerText);
			if (time) {
				time = [parseTime(time[1]), parseTime(time[2])];
			} else {
				console.warn(`Cannot parse time for CRN ${section.crn}: ${meet_time[i].innerText}`);
			}

			let location = meet_location[i].innerText.trim(); // TODO: parse location

			var meet_obj = {
				day: day,
				time: time,
				instructor: meet_instructor[i].innerText.trim().split('\n'),
				location: location,
				section: meet_section[i].innerText.trim(),
				type: meet_type[i].innerText.trim()
			};
			if (meet_obj.section != secobj.section) {
				console.warn(`Section inconsistent for CRN ${section.crn}: ${meet_obj.section} vs ${secobj.section}`);
			}
			if (meet_obj.type != secobj.type) {
				console.warn(`Type inconsistent for CRN ${section.crn}: ${meet_obj.type} vs ${secobj.type}`);
			}
			secobj.meetings.push(meet_obj);
		}

		// Date ranges
		var matches = /Meets (.*) - (.*)\./.exec(section.sectionDateRange);
		if (matches) {
			secobj.sectionDateRange = [parseDate(matches[1]), parseDate(matches[2])];
		} else {
			secobj.sectionDateRange = [];
			if (section.sectionDateRange)
				console.warn(`Failed to parse date range for CRN ${section.crn}: ${section.sectionDateRange}`);
		}
		matches = /Meets (.*) - (.*)\./.exec(section.courseDateRange);
		if (matches) {
			secobj.courseDateRange = [parseDate(matches[1]), parseDate(matches[2])];
		} else {
			secobj.courseDateRange = [];
			if (section.courseDateRange)
				console.warn(`Failed to parse date range for CRN ${section.crn}: ${section.courseDateRange}`);
		}

		// Restrictions
		secobj.restriction = html2text(section.restricted); // TODO parse restrictions

		// Optional copy
		secobj.title = section.sectionTitle?section.sectionTitle:"";
		secobj.info = section.info?section.info:"";
		secobj.description = section.sectionDescription?section.sectionDescription:"";
		secobj.course_desc = section.courseDescription?section.courseDescription:"";
		secobj.fee = section.sectionFee?section.sectionFee:"";
		secobj.special_approval = section.specialApproval?section.specialApproval:"";

		// Rare properties:
		secobj.approvalCode = section.approvalCode?console.info(`approvalCode ${section.approvalCode} at course ${course.code}`):"";
		secobj.corequest = section.corequest?console.info(`corequest ${section.corequest} at course ${course.code}`):"";
		secobj.courseDegreeNotes = section.courseDegreeNotes?console.info(`courseDegreeNotes ${section.courseDegreeNotes} at course ${course.code}`):"";
		secobj.sectionDegreeNotes = section.sectionDegreeNotes?console.info(`sectionDegreeNotes ${section.sectionDegreeNotes} at course ${course.code}`):"";
		secobj.approvalCode = section.approvalCode?console.info(`approvalCode ${section.approvalCode} at course ${course.code}`):"";

		// Copy
		secobj.crn = parseInt(section.crn);
		secobj.term = section.partOfTerm;

		if (!secsobj[secobj.type])
			secsobj[secobj.type] = [];
		secsobj[secobj.type].push(secobj);
	});
	return secsobj;
}

// Module: Course Object

// Constructor
var Course = function(htmlData) {
	this.doc = html2document(htmlData);

	let course_info = getCourseInfo(this.doc);
	Object.assign(this, parseInfo(course_info));

	let sectionDataObj = getSectionDataObj(this.doc);
	this.sections = parseSectionObj(sectionDataObj, this);

	return this;
}

// From URL: use promise
Course.fromURL = function(url) {
	var promise = new Promise((resolve, reject) => {
		let resolver = false;
		switch(url.split(':')[0]) {
			case 'http':
				resolver = http.get;
				break;
			case 'https':
				resolver = https.get;
				break;
			/*
			case 'file':
				resolver = fs.readFile;
				break;
			*/
			default:
				reject(`Protocol ${url.split(':')[0]} not supported.`);
				return;
		}
		resolver(url, (res) => {
			res.setEncoding('utf8');
			let data = '';
			res.on('data', (chunk) => {
				data += chunk;
			});
			res.on('end', () => {
				if (res.statusCode!=200) {
					reject(res.statusCode);
				} else {
					try {
						resolve(new Course(data));
					} catch(e) {
						reject(e);
					}
				}
			});
		}).on('error', (e) => {
			reject(e);
		})
	});
	return promise;
}

Course.STATUS = ['', 'Open', 'Restricted', 'Closed'];

module.exports = Course;
