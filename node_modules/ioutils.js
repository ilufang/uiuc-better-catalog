/**
 *	IO wrappers
 *
 *	Provides a read/write interface like WebStorage API for file, http and https
 */

"use strict";

const fs = require('fs');
const http = require('http');
const https = require('https');
const url = require('url');

var json_io = function(json) {
	// Warning: changes saved to this IO object is not permanent!!!
	if (!json) {
		json = {};
	}
	this.data = json;
	return this;
}

json_io.prototype.getItem = function(filename) {
	return this.data[filename];
};
json_io.prototype.setItem = function(filename, data) {
	this.data[filename] = data;
}

var fs_io = function(dirname, dirbase, async) {
	if (!dirbase) {
		dirbase = './';
	}
	if (dirname.substr(-1,1) != '/') {
		dirname += '/';
	}
	this.async = async;
	this.dirbase = dirbase;
	this.dirname = dirname;
	return this;
};

fs_io.prototype.getItem = function(filename) {
	if (this.async) {
		return new Promise((resolve, reject) => {
			// fs IO for file urls created from HTTP IO might access html documents
			// Therefore the auto .json extension is not applied.
			// Additionally, we also simulate DirectoryIndex behavior (/ => index.html)
			let uri = `${this.dirbase}${this.dirname}${filename}`;
			if (!filename) {
				uri = uri.substr(0, uri.length-1);
			}
			if (!fs.statSync(uri).isFile()) {
				if (uri.substr(-1,1) != '/') {
					uri += '/';
				}
				uri += 'index.html';
				if (!fs.statSync(uri).isFile()) {
					reject(404);
				}
			}
			fs.readFile(uri,(err, data) => {
				if (err) {
					reject(err);
				} else {
					resolve(data);
				}
			});
		});
	} else {
		return fs.readFileSync(`${this.dirbase}${this.dirname}${filename}.json`);
	}
};
fs_io.prototype.setItem = function(filename, data) {
	if (this.async) {
		console.warn('Async write called on file IO. This should not happen!');
		console.warn('Async file IO should only be created from http IO on file URLs!');
	} else {
		return fs.writeFileSync(`${this.dirbase}${this.dirname}${filename}.json`, data);
	}
};

var http_io = function(baseURL) {
	// Process URL
	this.cookies = {};
	if (baseURL.substr(0,7) == 'http://') {
		this.driver = http;
	} else if (baseURL.substr(0,8) == 'https://') {
		this.driver = https;
	} else if (baseURL.substr(0,7) == 'file://') {
		return new fs_io(baseURL.substr(7),'',true);
	} else {
		baseURL = 'http://'+baseURL;
		this.driver = http;
		console.warn(`baseURL (${baseURL}) does not contain a protocol! Assuming it is http...`);
	}

	// Enable keep-alive
	this.agent = new this.driver.Agent({
		keepAlive: true,
		keepAliveMsecs: 10000
	});

	if (baseURL.substr(-1,1)!='/') {
		baseURL += '/';
	}

	this.baseURL = baseURL;

	return this;
}

http_io.prototype.getItem = function(filename) {
	var uri = this.baseURL;
	if (!filename) {
		uri = uri.substr(0,uri.length-1);
	} else {
		if (filename.substr(0,1) == '/')
			filename = filename.substr(1);
		uri += filename;
	}
	return new Promise((resolve, reject) => {
		var cookies = "";
		for (var k in this.cookies) {
			cookies += `${k}=${this.cookies[k]};`;
		}
		this.driver.get(Object.assign(url.parse(uri), {
			headers: {
				'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36',
				'Cookies': cookies
			},
			agent: this.agent
		}), (res) => {
			res.setEncoding('utf8');
			if (res.headers['set-cookie']) {
				// Set cookies
				res.headers['set-cookie'].forEach((line) => {
					line = line.split(';')[0];
					let sep = line.indexOf('=');
					this.cookies[line.slice(0,sep)] = line.slice(sep+1);
				});
			}
			let data = '';
			res.on('data', (chunk) => {
				data += chunk;
			});
			res.on('end', () => {
				if (res.statusCode!=200) {
					reject(res.statusCode);
				} else {
					resolve(data);
				}
			});
		}).on('error', (e) => {
			reject(e);
		});
	});
};
http_io.prototype.setItem = function() {
	console.warn("Called setItem on HTTP stream. This should not happen!");
};

module.exports = {json_io, fs_io, http_io};
