"use strict";

const Course = require('course');

// IO proxies
const ioutils = require('ioutils');
const json_io = ioutils.json_io;
const fs_io = ioutils.fs_io;
const http_io = ioutils.http_io;

// Utilities
const utils = require('utils');
const html2document = utils.html2document;
const html2text = utils.html2text;

// The Catalog

var Catalog = function(depts, courses, term) {
	// Index courses into the catalog object
	this.courses = {};
	this.sections = {};
	this.term = term;
	for (var dept in depts) {
		this.courses[dept] = {name:depts[dept]};
	}
	courses.forEach((course) => {
		// Index courses by code
		let dept = course.dept;
		if (!this.courses[dept]) {
			console.warn(`Dept ${dept} not indexed!`);
			this.courses[dept] = {name: dept};
		}
		this.courses[dept][course.number] = course;

		// Index sections by CRN
		for (var type in course.sections) {
			course.sections[type].forEach((section) => {
				this.sections[section.crn] = section;
				section.course = course;
			});
		}
	});

	this.fetchIO = new http_io("https://courses.illinois.edu");

	return this;
};

Catalog.prototype.getCourse = function(code) {
	var code = Catalog.parseCourseCode(code);
	if (!code || !this.courses[code.dept] || !this.courses[code.dept][code.number]) {
		return null;
	}
	return this.courses[code.dept][code.number];
}

Catalog.prototype.update = function(code) {
	return new Promise((resolve, reject) => {
		code = Catalog.parseCourseCode(code);
		if (!code) {
			reject("Invalid course code");
			return;
		}
		// TODO: embed base urls into data
		Course.fromURL("/schedule/"+this.term+"/"+code.dept+"/"+code.number, this.fetchIO).then(((course) => {
			var oldsections = this.courses[code.dept][code.number].sections;
			var oldcrns = [];
			for (var type in oldsections) {
				oldsections[type].forEach((section) => {
					oldcrns.push(section.crn);
				});
			}

			this.courses[code.dept][code.number] = course;
			if (this.storage) {
				this.storage.setItem(`${code.dept}_${code.number}`, JSON.stringify(course));
			}

			var newcrns = [];
			for (var type in course.sections) {
				course.sections[type].forEach((section) => {
					var idx = oldcrns.indexOf(section.crn);
					if (idx == -1) {
						newcrns.push(section.crn);
					} else {
						oldcrns.splice(idx, 1);
					}
					this.sections[section.crn] = section;
					section.course = course;
				});
			}
			resolve({course: course, added: newcrns, removed: oldcrns});
		}).bind(this), (err) => {
			console.error(err);
			reject(err);
		});
	});
}

// Dump to filesystem/localstorage
Catalog.prototype.save = function(storage) {
	if (!storage) {
		if (!this.storage) {
			return false;
		}
		storage = this.storage;
	}
	let index = [], dept_index = {};
	for (var dept_code in this.courses) {
		let dept = this.courses[dept_code];
		for (var idx in dept) {
			if (idx == 'name') {
				dept_index[dept_code] = dept[idx];
			} else {
				let course = dept[idx], filename = `${dept_code}_${course.number}`;
				index.push(filename);
				storage.setItem(filename, JSON.stringify(course));
			}
		}
	}
	storage.setItem("index", JSON.stringify(index));
	storage.setItem("depts", JSON.stringify(dept_index));
	storage.setItem("meta", JSON.stringify({term: this.term}));
}


// Online-fetch utilities
let getTerm = function(term, io, cb) {
	return new Promise((resolve, reject) => {
		io.getItem('schedule/'+term).then((val) => {
			let table = html2document(val).querySelector("table#term-dt tbody");
			if (!table) {
				throw `Cannot get dept list for term ${term}`;
			}

			var depts = {}, dept_list = [], courses = [], ptr = 0;

			var dept_promise = Promise.resolve();

			table.querySelectorAll("tr").forEach((dept) => {
				let tds = dept.querySelectorAll('td');
				if (tds.length != 2) {
					if (cb.console)
					var console = cb.console;
					console.warn(`Unexpected td length for ${dept}`);
					return;
				}
				let	dept_code = tds[0].innerText.trim().toUpperCase(),
					dept_name = tds[1].innerText.trim(),
					dept_link = dept.querySelector('a').getAttribute('href');
				if (!dept_link) {
					if (cb.console)
						var console = cb.console;
					console.warn(`No link to ${dept_code}, skipping...`);
					return
				}
				depts[dept_code] = dept_name;
				dept_list.push({dept_name, dept_link});

				dept_promise = dept_promise.then(() => {
					if (cb) cb.console.log("Loading courses for "+dept_list[ptr].dept_name+"...");
					return getCoursesForDept(dept_list[ptr].dept_link, io);
				}).then((val) => {
					courses = courses.concat(val);
					ptr++;
					if(cb) cb.completeOne();
				}, (err) => {
					if (cb.console)
						var console = cb.console;
					console.warn(`Course fetch failed for ${dept_list[ptr].dept_name}`);
					console.warn(err);
					ptr++;
				});
			});
			if(cb) cb.setTaskCount(dept_list.length);

			dept_promise.then(() => {
				resolve({courses, depts});
			});
		}).catch((err) => {
			reject(err);
		});
	});
};

let getCoursesForDept = function(url, io) {
	return new Promise((resolve, reject) => {
		io.getItem(url).then((val) => {
			let table = html2document(val).querySelector('table#default-dt tbody');
			// var q = [[],[],[],[]], ptr = 0; // 4 Concurrent connections
			// var promises = [Promise.resolve(), Promise.resolve(), Promise.resolve(), Promise.resolve()];
			// q.io = io;
			var courses = [];
			table.querySelectorAll("tr").forEach((trow) => {
				var code, title;
				[code, title] = trow.querySelectorAll("td");
				code = code.innerText.trim();
				title = title.innerText.trim();
				courses.push(Course.templateFromCode(code, title));
			});
			resolve(courses);
			/*
			table.querySelectorAll('a').forEach((item) => {
				q[ptr].push(item.getAttribute('href'));

				promises[ptr] = promises[ptr].then( ( (i)=>{
					return Course.fromURL(q[i].pop(), io);
				} ).bind(this, ptr) );
				promises[ptr] = promises[ptr].then((fetched_course) => {
					courses.push(fetched_course);
				}, (err) => {
					console.warn("Cannot process course");
					console.warn(err);
				});

				++ptr;
				ptr%=4;
			});
			Promise.all(promises).then(() => {
				// console.log(`Fetched ${courses.length} courses for ${url}`);
				resolve(courses);
			});
			*/
		});
	});
}

// Initialization class methods

Catalog.fromTerm = function(term, baseURL, cb) {
	if (baseURL) {
		var io = new http_io(baseURL);
	} else {
		var io = new http_io("https://courses.illinois.edu");
	}
	if (!term) {
		term = "DEFAULT/DEFAULT";
	}
	return new Promise((resolve, reject) => {
		getTerm(term, io, cb).then((val) => {
			try {
				var catalog = new Catalog(val.depts, val.courses, term);
				// catalog.resolveDependencies();
				resolve(catalog);
			} catch(e) {
				reject(e);
			}
		}, (err) => {
			reject(err);
		});
	});
};

Catalog.fromStorage = function(storage) {
	if (!storage) {
		throw "Storage object unavailable";
	}
	let index = JSON.parse(storage.getItem('index'));
	let depts = JSON.parse(storage.getItem('depts'));
	let meta = JSON.parse(storage.getItem('meta'));
	var courses = [];
	index.forEach((file) => {
		let data = JSON.parse(storage.getItem(file));
		courses.push(new Course(data));
	});

	let catalog = new Catalog(depts, courses, meta.term);
	catalog.storage = storage;
	return catalog;
}

Catalog.fromLocalStorage = Catalog.fromStorage.bind({}, window.localStorage);

Catalog.fromDirectory = function(dirname) {
	return Catalog.fromStorage(new fs_io(dirname));
}

// Utility methods

Catalog.parseCourseCode = function(courseid) {
	try {
		var number = parseInt(/\d+/.exec(courseid)[0]);
		if (number < 100) {
			throw "Course number too low";
		}
		var dept = /[A-Za-z]*/.exec(courseid)[0].toUpperCase();
		return {dept, number};
	} catch(e) {
		return null;
	}
}

Catalog.getDefaultTerm = function() {
	return Promise.resolve().then(() => {
		var io = new http_io("https://courses.illinois.edu/schedule");
		return io.getItem("DEFAULT/DEFAULT").then((data) => {
			var doc = html2document(data);
			var term = doc.querySelector("h1").innerText;
			term = term.trim().toLowerCase();
			return term.replace(/(\w+) (\d+)/, "$2/$1");
		});
	});
}

module.exports = Catalog;
window.Catalog = Catalog;
